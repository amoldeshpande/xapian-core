<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classXapian_1_1QueryParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::QueryParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query. ">Xapian::Query</a> object from a user query string.  
 <a href="classXapian_1_1QueryParser.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae96a58a8de9d219ca3214a5a66e0407e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">feature_flag</a> { <br />
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde">FLAG_BOOLEAN</a> = 1, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b">FLAG_PHRASE</a> = 2, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd">FLAG_LOVEHATE</a> = 4, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d">FLAG_BOOLEAN_ANY_CASE</a> = 8, 
<br />
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a> = 16, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0">FLAG_PURE_NOT</a> = 32, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a> = 64, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c">FLAG_SPELLING_CORRECTION</a> = 128, 
<br />
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f">FLAG_SYNONYM</a> = 256, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b">FLAG_AUTO_SYNONYMS</a> = 512, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b">FLAG_AUTO_MULTIWORD_SYNONYMS</a> = 1024, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4c83dcc06ba2cd69c81521133dc68ff8">FLAG_CJK_NGRAM</a> = 2048, 
<br />
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a> = FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br />
 }<tr class="memdesc:ae96a58a8de9d219ca3214a5a66e0407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae96a58a8de9d219ca3214a5a66e0407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2959f7a1c5680f3fd1421d92445e220"><td class="memItemLeft" align="right" valign="top"><a id="ae2959f7a1c5680f3fd1421d92445e220"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> { <br />
&#160;&#160;<b>STEM_NONE</b>, 
<b>STEM_SOME</b>, 
<b>STEM_ALL</b>, 
<b>STEM_ALL_Z</b>, 
<br />
&#160;&#160;<b>STEM_SOME_FULL_POS</b>
<br />
 }<tr class="memdesc:ae2959f7a1c5680f3fd1421d92445e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stemming strategies, for use with <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy. ">set_stemming_strategy()</a>. <br /></td></tr>
</td></tr>
<tr class="separator:ae2959f7a1c5680f3fd1421d92445e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="memItemLeft" align="right" valign="top"><a id="a00d9afcf20b20cd9c8b3d22dd1bc82b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a00d9afcf20b20cd9c8b3d22dd1bc82b7">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18adb637032c2149a0457f2f79f332a5"><td class="memItemLeft" align="right" valign="top"><a id="a18adb637032c2149a0457f2f79f332a5"></a>
<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a18adb637032c2149a0457f2f79f332a5">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a18adb637032c2149a0457f2f79f332a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br /></td></tr>
<tr class="separator:a18adb637032c2149a0457f2f79f332a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724f1e26b785516c4c8cde78455f9cd5"><td class="memItemLeft" align="right" valign="top"><a id="a724f1e26b785516c4c8cde78455f9cd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a724f1e26b785516c4c8cde78455f9cd5">QueryParser</a> ()</td></tr>
<tr class="memdesc:a724f1e26b785516c4c8cde78455f9cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a724f1e26b785516c4c8cde78455f9cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d48b819b0c6d6a29f86a756f91d047"><td class="memItemLeft" align="right" valign="top"><a id="a69d48b819b0c6d6a29f86a756f91d047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a69d48b819b0c6d6a29f86a756f91d047">~QueryParser</a> ()</td></tr>
<tr class="memdesc:a69d48b819b0c6d6a29f86a756f91d047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a69d48b819b0c6d6a29f86a756f91d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2312c9865a58cc1149fe7cda9f0c2585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2312c9865a58cc1149fe7cda9f0c2585">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>
<tr class="memdesc:a2312c9865a58cc1149fe7cda9f0c2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemmer.  <a href="#a2312c9865a58cc1149fe7cda9f0c2585">More...</a><br /></td></tr>
<tr class="separator:a2312c9865a58cc1149fe7cda9f0c2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd">set_stemming_strategy</a> (<a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> strategy)</td></tr>
<tr class="memdesc:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemming strategy.  <a href="#ac7dc3b55b6083bd3ff98fc8b2726c8fd">More...</a><br /></td></tr>
<tr class="separator:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1046610676f72ba564108f0df5d77ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ab1046610676f72ba564108f0df5d77ab">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>
<tr class="memdesc:ab1046610676f72ba564108f0df5d77ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stopper.  <a href="#ab1046610676f72ba564108f0df5d77ab">More...</a><br /></td></tr>
<tr class="separator:ab1046610676f72ba564108f0df5d77ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe48be88c4872afec4bc963f417ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2efe48be88c4872afec4bc963f417ea5">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> default_op)</td></tr>
<tr class="memdesc:a2efe48be88c4872afec4bc963f417ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default operator.  <a href="#a2efe48be88c4872afec4bc963f417ea5">More...</a><br /></td></tr>
<tr class="separator:a2efe48be88c4872afec4bc963f417ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21692986aad0dfae791459cbbf36175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac21692986aad0dfae791459cbbf36175">get_default_op</a> () const</td></tr>
<tr class="memdesc:ac21692986aad0dfae791459cbbf36175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default operator.  <a href="#ac21692986aad0dfae791459cbbf36175">More...</a><br /></td></tr>
<tr class="separator:ac21692986aad0dfae791459cbbf36175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d221ba746506e51d9ea596ecb2cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>
<tr class="memdesc:a576d221ba746506e51d9ea596ecb2cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the database being searched.  <a href="#a576d221ba746506e51d9ea596ecb2cf6">More...</a><br /></td></tr>
<tr class="separator:a576d221ba746506e51d9ea596ecb2cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabe68a4eb93a05150ae7cf070d33752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#afabe68a4eb93a05150ae7cf070d33752">set_max_expansion</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> max_expansion, int max_type=<a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a>, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a>|<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a>)</td></tr>
<tr class="memdesc:afabe68a4eb93a05150ae7cf070d33752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard and/or partial term.  <a href="#afabe68a4eb93a05150ae7cf070d33752">More...</a><br /></td></tr>
<tr class="separator:afabe68a4eb93a05150ae7cf070d33752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2651e3363f82933b5c6e350bab6d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0a2651e3363f82933b5c6e350bab6d8b">set_max_wildcard_expansion</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>)</td></tr>
<tr class="memdesc:a0a2651e3363f82933b5c6e350bab6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard.  <a href="#a0a2651e3363f82933b5c6e350bab6d8b">More...</a><br /></td></tr>
<tr class="separator:a0a2651e3363f82933b5c6e350bab6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2">parse_query</a> (const std::string &amp;query_string, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a>, const std::string &amp;default_prefix=std::string())</td></tr>
<tr class="memdesc:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a query.  <a href="#a73d32cc7f862ab2e3fdd7da61f352fb2">More...</a><br /></td></tr>
<tr class="separator:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4829ddcaa0582ff94d1066870a18c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ad4829ddcaa0582ff94d1066870a18c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a free-text field term prefix.  <a href="#ad4829ddcaa0582ff94d1066870a18c97">More...</a><br /></td></tr>
<tr class="separator:ad4829ddcaa0582ff94d1066870a18c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6b58293a8e0e0d1db354362c5b7e19"><td class="memItemLeft" align="right" valign="top"><a id="a3c6b58293a8e0e0d1db354362c5b7e19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a3c6b58293a8e0e0d1db354362c5b7e19">add_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc)</td></tr>
<tr class="memdesc:a3c6b58293a8e0e0d1db354362c5b7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors. ">FieldProcessor</a>. <br /></td></tr>
<tr class="separator:a3c6b58293a8e0e0d1db354362c5b7e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8590431c481fe0eea43cd4ce619a0816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:a8590431c481fe0eea43cd4ce619a0816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#a8590431c481fe0eea43cd4ce619a0816">More...</a><br /></td></tr>
<tr class="separator:a8590431c481fe0eea43cd4ce619a0816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d25f9297bb98c2101a03ff3d60cf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a67d25f9297bb98c2101a03ff3d60cf30">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, bool exclusive)</td></tr>
<tr class="memdesc:a67d25f9297bb98c2101a03ff3d60cf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#a67d25f9297bb98c2101a03ff3d60cf30">More...</a><br /></td></tr>
<tr class="separator:a67d25f9297bb98c2101a03ff3d60cf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad475afb6389e05cf996a862a9305c666"><td class="memItemLeft" align="right" valign="top"><a id="ad475afb6389e05cf996a862a9305c666"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad475afb6389e05cf996a862a9305c666">add_boolean_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:ad475afb6389e05cf996a862a9305c666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors. ">FieldProcessor</a> for a boolean prefix. <br /></td></tr>
<tr class="separator:ad475afb6389e05cf996a862a9305c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead663f25674137f723c58b1ceaf5071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#aead663f25674137f723c58b1ceaf5071">add_boolean_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc, bool exclusive)</td></tr>
<tr class="memdesc:aead663f25674137f723c58b1ceaf5071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors. ">FieldProcessor</a> for a boolean prefix.  <a href="#aead663f25674137f723c58b1ceaf5071">More...</a><br /></td></tr>
<tr class="separator:aead663f25674137f723c58b1ceaf5071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c90c2951a57d9c93efe469dfcb1faec"><td class="memItemLeft" align="right" valign="top"><a id="a6c90c2951a57d9c93efe469dfcb1faec"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a6c90c2951a57d9c93efe469dfcb1faec">stoplist_begin</a> () const</td></tr>
<tr class="memdesc:a6c90c2951a57d9c93efe469dfcb1faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator over terms omitted from the query as stopwords. <br /></td></tr>
<tr class="separator:a6c90c2951a57d9c93efe469dfcb1faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff57d1cfce464a83d471acc1044789e"><td class="memItemLeft" align="right" valign="top"><a id="a3ff57d1cfce464a83d471acc1044789e"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a3ff57d1cfce464a83d471acc1044789e">stoplist_end</a> () const</td></tr>
<tr class="memdesc:a3ff57d1cfce464a83d471acc1044789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator over terms omitted from the query as stopwords. <br /></td></tr>
<tr class="separator:a3ff57d1cfce464a83d471acc1044789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6b1caa3b6fc4e7cc1d2560eef8080"><td class="memItemLeft" align="right" valign="top"><a id="a0ff6b1caa3b6fc4e7cc1d2560eef8080"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0ff6b1caa3b6fc4e7cc1d2560eef8080">unstem_begin</a> (const std::string &amp;term) const</td></tr>
<tr class="memdesc:a0ff6b1caa3b6fc4e7cc1d2560eef8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator over unstemmed forms of the given stemmed query term. <br /></td></tr>
<tr class="separator:a0ff6b1caa3b6fc4e7cc1d2560eef8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3326d7535907a73a4ec37f4d39887f"><td class="memItemLeft" align="right" valign="top"><a id="afc3326d7535907a73a4ec37f4d39887f"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#afc3326d7535907a73a4ec37f4d39887f">unstem_end</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:afc3326d7535907a73a4ec37f4d39887f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator over unstemmed forms of the given stemmed query term. <br /></td></tr>
<tr class="separator:afc3326d7535907a73a4ec37f4d39887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e15e0a73460b2134ca202273d513b9"><td class="memItemLeft" align="right" valign="top"><a id="af8e15e0a73460b2134ca202273d513b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#af8e15e0a73460b2134ca202273d513b9">add_rangeprocessor</a> (<a class="el" href="classXapian_1_1RangeProcessor.html">Xapian::RangeProcessor</a> *range_proc, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:af8e15e0a73460b2134ca202273d513b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1RangeProcessor.html" title="Base class for range processors. ">RangeProcessor</a>. <br /></td></tr>
<tr class="separator:af8e15e0a73460b2134ca202273d513b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8583a9f044f2eb33859b442a8aea76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8f8583a9f044f2eb33859b442a8aea76">add_valuerangeprocessor</a> (<a class="el" href="classXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>
<tr class="memdesc:a8f8583a9f044f2eb33859b442a8aea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors. ">ValueRangeProcessor</a>.  <a href="#a8f8583a9f044f2eb33859b442a8aea76">More...</a><br /></td></tr>
<tr class="separator:a8f8583a9f044f2eb33859b442a8aea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e3dfc618f2583f3b1458d4c07325c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a84e3dfc618f2583f3b1458d4c07325c1">get_corrected_query_string</a> () const</td></tr>
<tr class="memdesc:a84e3dfc618f2583f3b1458d4c07325c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#a84e3dfc618f2583f3b1458d4c07325c1">More...</a><br /></td></tr>
<tr class="separator:a84e3dfc618f2583f3b1458d4c07325c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f72461f74e86bb2ad35b0eebaef1c"><td class="memItemLeft" align="right" valign="top"><a id="a656f72461f74e86bb2ad35b0eebaef1c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a656f72461f74e86bb2ad35b0eebaef1c">get_description</a> () const</td></tr>
<tr class="memdesc:a656f72461f74e86bb2ad35b0eebaef1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br /></td></tr>
<tr class="separator:a656f72461f74e86bb2ad35b0eebaef1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query. ">Xapian::Query</a> object from a user query string. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae96a58a8de9d219ca3214a5a66e0407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96a58a8de9d219ca3214a5a66e0407e">&#9670;&nbsp;</a></span>feature_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">Xapian::QueryParser::feature_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum of feature flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde"></a>FLAG_BOOLEAN&#160;</td><td class="fielddoc"><p>Support AND, OR, etc and bracketed subexpressions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b"></a>FLAG_PHRASE&#160;</td><td class="fielddoc"><p>Support quoted phrases. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd"></a>FLAG_LOVEHATE&#160;</td><td class="fielddoc"><p>Support + and -. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d"></a>FLAG_BOOLEAN_ANY_CASE&#160;</td><td class="fielddoc"><p>Support AND, OR, etc even if they aren't in ALLCAPS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36"></a>FLAG_WILDCARD&#160;</td><td class="fielddoc"><p>Support wildcards. </p>
<p>At present only right truncation (e.g. Xap*) is supported.</p>
<p>Currently you can't use wildcards with boolean filter prefixes, or in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation).</p>
<p>In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.x, you needed to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string. ">QueryParser</a> object which database to expand wildcards from by calling <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a>. In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.3.3, OP_WILDCARD was added and wildcards are now expanded when <a class="el" href="classXapian_1_1Enquire.html#aab6fba434e5ddbbea2adcab85ba5ba4a" title="Get (a portion of) the match set for the current query. ">Enquire::get_mset()</a> is called, with the expansion using the database being searched. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0"></a>FLAG_PURE_NOT&#160;</td><td class="fielddoc"><p>Allow queries such as 'NOT apples'. </p>
<p>These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7"></a>FLAG_PARTIAL&#160;</td><td class="fielddoc"><p>Enable partial matching. </p>
<p>Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.</p>
<p>Currently FLAG_PARTIAL doesn't do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn't do anything if if the final word is part of a value range.</p>
<p>In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.x, you needed to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string. ">QueryParser</a> object which database to expand wildcards from by calling <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a>. In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.3.3, OP_WILDCARD was added and wildcards are now expanded when <a class="el" href="classXapian_1_1Enquire.html#aab6fba434e5ddbbea2adcab85ba5ba4a" title="Get (a portion of) the match set for the current query. ">Enquire::get_mset()</a> is called, with the expansion using the database being searched. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c"></a>FLAG_SPELLING_CORRECTION&#160;</td><td class="fielddoc"><p>Enable spelling correction. </p>
<p>For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#a3575c96a597a5555e474360d91b7622b" title="Suggest a spelling correction. ">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#a84e3dfc618f2583f3b1458d4c07325c1" title="Get the spelling-corrected query string. ">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">QueryParser::parse_query()</a> again.</p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f"></a>FLAG_SYNONYM&#160;</td><td class="fielddoc"><p>Enable synonym operator '~'. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b"></a>FLAG_AUTO_SYNONYMS&#160;</td><td class="fielddoc"><p>Enable automatic use of synonyms for single terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b"></a>FLAG_AUTO_MULTIWORD_SYNONYMS&#160;</td><td class="fielddoc"><p>Enable automatic use of synonyms for single terms and groups of terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea4c83dcc06ba2cd69c81521133dc68ff8"></a>FLAG_CJK_NGRAM&#160;</td><td class="fielddoc"><p>Enable generation of n-grams from CJK text. </p>
<p>With this enabled, spans of CJK characters are split into unigrams and bigrams, with the unigrams carrying positional information. Non-CJK characters are split into words as normal.</p>
<p>The corresponding option needs to have been used at index time.</p>
<p>Flag added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.3.4 and 1.2.22, but this mode can be enabled in 1.2.8 and later by setting environment variable XAPIAN_CJK_NGRAM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a"></a>FLAG_DEFAULT&#160;</td><td class="fielddoc"><p>The default flags. </p>
<p>Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">parse_query()</a></em>. The default flags are FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE.</p>
<p>Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.0.11. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8590431c481fe0eea43cd4ce619a0816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8590431c481fe0eea43cd4ce619a0816">&#9670;&nbsp;</a></span>add_boolean_prefix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>grouping</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </p>
<p>For example:</p>
<div class="fragment"><div class="line">qp.add_boolean_prefix(<span class="stringliteral">&quot;site&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>);</div></div><!-- fragment --><p>This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any weighted query with <code>Xapian::Query::OP_FILTER</code>.</p>
<p>If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code>Xapian::Query::OP_OR</code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code>Xapian::Query::OP_AND</code> operator.</p>
<p>Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.</p>
<p>For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>Calling this method with an empty string for <em>field</em> will cause a <code><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></code>.</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a free-text field term prefix. ">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way. ">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
    <tr><td class="paramname">grouping</td><td>Controls how multiple filters are combined - filters with the same grouping value are combined with OP_OR, then the resulting queries are combined with OP_AND. If NULL, then <em>field</em> is used for grouping. If an empty string, then a unique grouping is created for each filter (this is sometimes useful when each document can have multiple terms with this prefix). [default: NULL] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d25f9297bb98c2101a03ff3d60cf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d25f9297bb98c2101a03ff3d60cf30">&#9670;&nbsp;</a></span>add_boolean_prefix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </p>
<p>This is an older version of this method - use the version with the <code>grouping</code> parameter in preference to this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
    <tr><td class="paramname">exclusive</td><td>Controls how multiple filters are combined. If true then <em>prefix</em> is used as the <code>grouping</code> value, so terms with the same prefix are combined with OP_OR, then the resulting queries are combined with OP_AND. If false, then a unique grouping is created for each filter (this is sometimes useful when each document can have multiple terms with this prefix). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aead663f25674137f723c58b1ceaf5071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead663f25674137f723c58b1ceaf5071">&#9670;&nbsp;</a></span>add_boolean_prefix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors. ">FieldProcessor</a> for a boolean prefix. </p>
<p>This is an older version of this method - use the version with the <code>grouping</code> parameter in preference to this one. </p>

</div>
</div>
<a id="ad4829ddcaa0582ff94d1066870a18c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4829ddcaa0582ff94d1066870a18c97">&#9670;&nbsp;</a></span>add_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a free-text field term prefix. </p>
<p>For example:</p>
<div class="fragment"><div class="line">qp.add_prefix(<span class="stringliteral">&quot;author&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div></div><!-- fragment --><p>This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".</p>
<p>Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.</p>
<p>If the prefix parameter is empty, then "field:word" will produce the term "word" (and this can be one of several prefixes for a particular field, or for terms without a field specifier).</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a free-text field term prefix. ">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way. ">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f8583a9f044f2eb33859b442a8aea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8583a9f044f2eb33859b442a8aea76">&#9670;&nbsp;</a></span>add_valuerangeprocessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_valuerangeprocessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *&#160;</td>
          <td class="paramname"><em>vrproc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a <a class="el" href="classXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors. ">ValueRangeProcessor</a>. </p>
<p>This method is provided for API compatibility with <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.x and is deprecated - use <em><a class="el" href="classXapian_1_1QueryParser.html#af8e15e0a73460b2134ca202273d513b9" title="Register a RangeProcessor. ">add_rangeprocessor()</a></em> with a <a class="el" href="classXapian_1_1RangeProcessor.html" title="Base class for range processors. ">RangeProcessor</a> instead. </p>
<p>Compatibility shim. </p>

<p class="reference">References <a class="el" href="namespaceXapian.html#a0a75ef120e641c77f703e60f595ffda2">Xapian::BAD_VALUENO</a>, and <a class="el" href="classXapian_1_1RangeProcessor.html#a4e84753e4553ae7515edb4ef12da55b0">Xapian::RangeProcessor::operator()()</a>.</p>

</div>
</div>
<a id="a84e3dfc618f2583f3b1458d4c07325c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e3dfc618f2583f3b1458d4c07325c1">&#9670;&nbsp;</a></span>get_corrected_query_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_corrected_query_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spelling-corrected query string. </p>
<p>This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">QueryParser::parse_query()</a> was last called.</p>
<p>If there were no corrections, an empty string is returned. </p>

</div>
</div>
<a id="ac21692986aad0dfae791459cbbf36175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21692986aad0dfae791459cbbf36175">&#9670;&nbsp;</a></span>get_default_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> Xapian::QueryParser::get_default_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current default operator. </p>

</div>
</div>
<a id="a73d32cc7f862ab2e3fdd7da61f352fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d32cc7f862ab2e3fdd7da61f352fb2">&#9670;&nbsp;</a></span>parse_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::QueryParser::parse_query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_prefix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query_string</td><td>A free-text query as entered by a user </td></tr>
    <tr><td class="paramname">flags</td><td>Zero or more <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e" title="Enum of feature flags. ">QueryParser::feature_flag</a> specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string. ">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td class="paramname">default_prefix</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the query string can't be parsed, then <a class="el" href="classXapian_1_1QueryParserError.html" title="Indicates a query string can&#39;t be parsed. ">Xapian::QueryParserError</a> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Unknown range operation </li>
<li>parse error </li>
<li>Syntax: &lt;expression&gt; AND &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; AND NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; OR &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; XOR &lt;expression&gt; </li>
</ul>

</div>
</div>
<a id="a576d221ba746506e51d9ea596ecb2cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d221ba746506e51d9ea596ecb2cf6">&#9670;&nbsp;</a></span>set_database()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_database </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the database being searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>The database to use for spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2efe48be88c4872afec4bc963f417ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efe48be88c4872afec4bc963f417ea5">&#9670;&nbsp;</a></span>set_default_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_default_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td>
          <td class="paramname"><em>default_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_op</td><td>The operator to use to combine non-filter query items when no explicit operator is used.</td></tr>
  </table>
  </dd>
</dl>
<p>So for example, 'weather forecast' is parsed as if it were 'weather OR forecast' by default.</p>
<p>The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR, OP_PHRASE, OP_ELITE_SET, OP_SYNONYM and OP_MAX are also permitted. Passing other values will result in <a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">InvalidArgumentError</a> being thrown. </p>

</div>
</div>
<a id="afabe68a4eb93a05150ae7cf070d33752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabe68a4eb93a05150ae7cf070d33752">&#9670;&nbsp;</a></span>set_max_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_expansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>max_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_type</em> = <code><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a>|<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the maximum expansion of a wildcard and/or partial term. </p>
<p>Note: you must also set FLAG_WILDCARD and/or FLAG_PARTIAL in the flags parameter to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">parse_query()</a></em> for this setting to have anything to affect.</p>
<p>If you don't call this method, the default settings are no limit on wildcard expansion, and partial terms expanding to the most frequent 100 terms - i.e. as if you'd called:</p>
<p>set_max_expansion(0); set_max_expansion(100, Xapian::Query::WILDCARD_LIMIT_MOST_FREQUENT, Xapian::QueryParser::FLAG_PARTIAL);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_expansion</td><td>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </td></tr>
    <tr><td class="paramname">max_type</td><td><em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit. ">Xapian::Query::WILDCARD_LIMIT_ERROR</a></em>, <em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa08d373f6c100bdbff9420dc51a621f2" title="Stop expanding when OP_WILDCARD reaches its expansion limit. ">Xapian::Query::WILDCARD_LIMIT_FIRST</a></em> or <em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa1568bc15280d8c8a10128d3b7f1db71" title="Limit OP_WILDCARD expansion to the most frequent terms. ">Xapian::Query::WILDCARD_LIMIT_MOST_FREQUENT</a></em> (default: <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit. ">Xapian::Query::WILDCARD_LIMIT_ERROR</a>). </td></tr>
    <tr><td class="paramname">flags</td><td>What to set the limit for (default: FLAG_WILDCARD|FLAG_PARTIAL, setting the limit for both wildcards and partial terms).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.3.3 </dd></dl>

</div>
</div>
<a id="a0a2651e3363f82933b5c6e350bab6d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2651e3363f82933b5c6e350bab6d8b">&#9670;&nbsp;</a></span>set_max_wildcard_expansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_wildcard_expansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>max_expansion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify the maximum expansion of a wildcard. </p>
<p>If any wildcard expands to more than <em>max_expansion</em> terms, an exception will be thrown.</p>
<p>This method is provided for API compatibility with <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.x and is deprecated - replace it with:</p>
<p>set_max_wildcard_expansion(max_expansion, <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit. ">Xapian::Query::WILDCARD_LIMIT_ERROR</a>, <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36" title="Support wildcards. ">Xapian::QueryParser::FLAG_WILDCARD</a>); </p>

<p class="reference">References <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a>.</p>

</div>
</div>
<a id="a2312c9865a58cc1149fe7cda9f0c2585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2312c9865a58cc1149fe7cda9f0c2585">&#9670;&nbsp;</a></span>set_stemmer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&#160;</td>
          <td class="paramname"><em>stemmer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemmer. </p>
<p>This sets the stemming algorithm which will be used by the query parser. The stemming algorithm will be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy. ">set_stemming_strategy()</a>. As of 1.3.1, this defaults to STEM_SOME, but in earlier versions the default was STEM_NONE. If you want to work with older versions, you should explicitly set a stemming strategy as well as setting a stemmer, otherwise your stemmer won't actually be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stemmer</td><td>The <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm. ">Xapian::Stem</a> object to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dc3b55b6083bd3ff98fc8b2726c8fd">&#9670;&nbsp;</a></span>set_stemming_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemming_strategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemming strategy. </p>
<p>This controls how the query parser will apply the stemming algorithm. Note that the stemming algorithm is only applied to words in free-text fields - boolean filter terms are never stemmed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The strategy to use - possible values are:<ul>
<li>STEM_NONE: Don't perform any stemming. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> &lt;= 1.3.0)</li>
<li>STEM_SOME: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm. ">Stem</a> all terms except for those which start with a capital letter, or are followed by certain characters (currently: <code>(/@&lt;&gt;=*[{"</code> ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> &gt;= 1.3.1)</li>
<li>STEM_SOME_FULL_POS: Like STEM_SOME but also stems terms used with operators which need positional information. Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.4.8.</li>
<li>STEM_ALL: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm. ">Stem</a> all terms (note: no 'Z' prefix is added).</li>
<li>STEM_ALL_Z: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm. ">Stem</a> all terms (note: 'Z' prefix is added). (new in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.11 and 1.3.1) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1046610676f72ba564108f0df5d77ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1046610676f72ba564108f0df5d77ab">&#9670;&nbsp;</a></span>set_stopper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stopper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&#160;</td>
          <td class="paramname"><em>stop</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stopper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>The <a class="el" href="classXapian_1_1Stopper.html" title="Base class for stop-word decision functor. ">Stopper</a> object to set (default NULL, which means no stopwords). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="queryparser_8h.html">queryparser.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.4.9).<br>
Generated on Sat Nov 3 2018 by
<a href="http://www.doxygen.org/">Doxygen 1.8.13</a>.
</small></address>
</body>
</html>
